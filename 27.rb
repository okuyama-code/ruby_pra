arr = [1, "a", 2, "b", "c", 3, "4", "5", "6"]

new_arr = arr.select{ |v| v.to_s =~ /^[0-9]+$/ }

p new_arr # [1, 2, 3, "4", "5", "6"]

new_arr = new_arr.map{ |v| v.to_i }.sort.reverse

p new_arr


# # 元の配列
# arr = [1, "a", 2, "b", "c", 3, "4", "5", "6"]

# # 新しい配列を生成し、条件を満たす要素のみを選択します
# # 条件式 /^[0-9]+$/ は、正規表現を使用して、文字列が数字のみで構成されているかをチェックします。
# # ^ は行の先頭を意味し、[0-9] は数字を表します。+ は直前の文字が1回以上繰り返されることを意味します。
# # $ は行の末尾を意味します。つまり、文字列全体が数字のみで構成されていることを示します。
# new_arr = arr.select { |v| v.to_s =~ /^[0-9]+$/ }

# # 新しい配列を出力します
# p new_arr

# =~ は、Rubyの正規表現演算子です。この演算子は、左側のオブジェクト（通常は文字列）が右側の正規表現パターンと一致するかどうかを調べます。

# 具体的には、=~ 演算子は、左側のオブジェクトが右側の正規表現パターンにマッチする場合はマッチした位置（インデックス）を返し、マッチしない場合は nil を返します。

# 例えば、次のように使用されます：

# ruby
# Copy code
# str = "apple"
# result = str =~ /p/ # "p" にマッチするので、2 を返します
# puts result # 2 を出力

# result = str =~ /z/ # "z" にはマッチしないので、nil を返します
# puts result # nil を出力
# この場合、v.to_s =~ /^[0-9]+$/ の部分では、v.to_s で変数 v を文字列に変換し、その文字列が /^[0-9]+$/ という正規表現パターンにマッチするかどうかを調べています。
